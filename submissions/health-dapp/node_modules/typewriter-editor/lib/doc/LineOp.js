import Line from './Line';
import Op, { OpIterator } from '../delta/Op';
var LineOp;
(function (LineOp) {
    function iterator(lines, lineIds) {
        return new LineOpIterator(lines, lineIds);
    }
    LineOp.iterator = iterator;
    function length(op) {
        return Op.length(op);
    }
    LineOp.length = length;
})(LineOp || (LineOp = {}));
export default LineOp;
export class LineOpIterator {
    constructor(lines, lineIds) {
        this.lineIterator = Line.iterator(lines, lineIds);
        const line = this.lineIterator.peek();
        this.opIterator = Op.iterator((line === null || line === void 0 ? void 0 : line.content.ops) || []);
    }
    hasNext() {
        return this.opIterator.hasNext() || this.lineIterator.hasNext();
    }
    next(length) {
        let op = this.opIterator.next(length);
        if (op.retain === Infinity && this.lineIterator.hasNext()) {
            op = getLineOp(this.nextLine());
        }
        return op;
    }
    nextLine() {
        const line = this.lineIterator.next();
        const nextLine = this.lineIterator.peek();
        this.opIterator = new OpIterator((nextLine === null || nextLine === void 0 ? void 0 : nextLine.content.ops) || []);
        return line;
    }
    peek() {
        if (this.opIterator.hasNext() || !this.lineIterator.hasNext()) {
            return this.opIterator.peek();
        }
        else {
            return getLineOp(this.peekLine());
        }
    }
    peekLine() {
        return this.lineIterator.peek();
    }
    peekLength() {
        if (this.opIterator.hasNext() || !this.lineIterator.hasNext()) {
            return this.opIterator.peekLength();
        }
        else {
            return 1; // a newline is length 1
        }
    }
    peekLineLength() {
        return this.lineIterator.peekLength();
    }
    peekType() {
        if (this.opIterator.hasNext()) {
            return this.opIterator.peekType();
        }
        else if (this.lineIterator.hasNext()) {
            return 'insert'; // insert: '\n'
        }
        else {
            return 'retain';
        }
    }
    restCurrentLine() {
        return this.opIterator.rest();
    }
    restLines() {
        if (this.opIterator.offset) {
            this.lineIterator.next(this.opIterator.offset);
        }
        return this.lineIterator.rest();
    }
}
function getLineOp(line) {
    const op = { insert: '\n' };
    if (line.attributes)
        op.attributes = line.attributes;
    return op;
}
//# sourceMappingURL=LineOp.js.map